<!DOCTYPE html>
<html lang="sw">
  <head>
    <meta charset="UTF-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"
    />
    <title>KADI 254 - Online</title>

    <!-- Socket.IO client -->
    <script src="https://cdn.socket.io/4.7.2/socket.io.min.js"></script>

    <!-- Fonts -->
    <link
      href="https://fonts.googleapis.com/css2?family=Bangers&family=Poppins:wght@700;900&display=swap"
      rel="stylesheet"
    />
    <script src="https://cdn.jsdelivr.net/npm/canvas-confetti@1.9.2/dist/confetti.browser.min.js"></script>

    <style>
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }
      body {
        background: #000;
        font-family: Poppins;
        overflow: hidden;
        height: 100vh;
        color: #fff;
      }
      #lobby,
      #game {
        width: 100%;
        height: 100%;
        position: absolute;
        top: 0;
        left: 0;
      }
      #lobby {
        background: linear-gradient(135deg, #000, #1a1a1a);
        color: #0f0;
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        gap: 20px;
      }
      .btn {
        padding: 15px 40px;
        font-size: 1.5rem;
        background: #0f0;
        color: #000;
        border: none;
        border-radius: 50px;
        cursor: pointer;
      }
      #roomCode {
        font-size: 3rem;
        font-family: Bangers;
        letter-spacing: 5px;
      }
      #game {
        display: none;
      }
      #info {
        position: absolute;
        top: 15px;
        left: 15px;
        z-index: 100;
        background: rgba(0, 0, 0, 0.85);
        padding: 10px 18px;
        border-radius: 15px;
        border: 3px solid #0f0;
        box-shadow: 0 0 25px rgba(0, 255, 0, 0.6);
        font-family: Bangers;
        font-size: 1.6rem;
      }
      #cardsInfo {
        position: absolute;
        bottom: 15px;
        left: 15px;
        z-index: 100;
        background: rgba(0, 0, 0, 0.75);
        padding: 8px 15px;
        border-radius: 12px;
        border: 2px solid #0ff;
        font-size: 0.9rem;
        color: #0ff;
      }
      #message {
        position: absolute;
        top: 20px;
        right: 20px;
        z-index: 150;
        background: rgba(0, 0, 0, 0.95);
        padding: 12px 30px;
        border-radius: 20px;
        border: 4px solid #ff0;
        font-family: Bangers;
        font-size: 1.8rem;
        text-align: center;
        animation: pop 0.4s;
        pointer-events: none;
        box-shadow: 0 0 40px rgba(255, 255, 0, 0.8);
        max-width: 300px;
      }
      #hint {
        position: absolute;
        bottom: 15px;
        left: 15px;
        z-index: 100;
        background: rgba(0, 0, 0, 0.9);
        padding: 8px 16px;
        border-radius: 12px;
        border: 2px solid #0ff;
        font-size: 0.85rem;
        color: #0ff;
        opacity: 0;
        transition: opacity 0.3s;
        max-width: 250px;
      }
      #hint.show {
        opacity: 1;
      }
      #winScreen {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.98);
        display: none;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        z-index: 1000;
      }
      #winScreen.show {
        display: flex;
      }
      #winText {
        font-family: Bangers;
        font-size: 6rem;
        text-shadow: 0 0 40px #0f0;
        margin-bottom: 40px;
      }
      .playAgain {
        padding: 25px 90px;
        font-size: 2.3rem;
        background: #0f0;
        color: #000;
        border: none;
        border-radius: 60px;
        cursor: pointer;
        font-weight: 900;
        transition: all 0.3s;
      }
      .playAgain:hover {
        transform: scale(1.05);
        box-shadow: 0 0 40px #0f0;
      }
      .backHome {
        margin-top: 20px;
        padding: 15px 50px;
        font-size: 1.5rem;
        background: transparent;
        color: #fff;
        border: 3px solid #fff;
        border-radius: 40px;
        cursor: pointer;
        font-weight: 700;
        transition: all 0.3s;
      }
      .backHome:hover {
        background: #fff;
        color: #000;
      }
      @keyframes pop {
        0% {
          opacity: 0;
          transform: scale(0.8);
        }
        100% {
          opacity: 1;
          transform: scale(1);
        }
      }
      @media (max-width: 768px) {
        #info {
          font-size: 1.3rem;
          padding: 8px 15px;
        }
        #cardsInfo {
          font-size: 0.8rem;
          padding: 6px 12px;
        }
        #message {
          top: 80px;
          right: 10px;
          left: 10px;
          font-size: 1.4rem;
          padding: 10px 20px;
          max-width: none;
        }
        #hint {
          font-size: 0.75rem;
          padding: 6px 12px;
          max-width: 200px;
        }
        #winText {
          font-size: 3.5rem;
        }
        .playAgain {
          padding: 20px 60px;
          font-size: 1.8rem;
        }
        .backHome {
          padding: 12px 40px;
          font-size: 1.2rem;
        }
      }
    </style>
  </head>
  <body>
    <!-- ====================== LOBBY ====================== -->
    <div id="lobby">
      <h1 style="font-family: Bangers; font-size: 4rem; color: #0f0">
        KADI 254
      </h1>
      <button class="btn" id="createBtn">CREATE ROOM</button>
      <div id="joinSection" style="display: none">
        <input
          id="codeInput"
          placeholder="Enter Code"
          style="
            padding: 15px;
            font-size: 1.5rem;
            width: 200px;
            text-align: center;
          "
        />
        <button class="btn" id="joinBtn">JOIN</button>
      </div>
      <div id="roomCode"></div>
      <button class="btn" id="showJoin" style="background: #ff0; color: #000">
        Join Existing Room
      </button>
    </div>

    <!-- ====================== GAME ====================== -->
    <div id="game">
      <canvas id="canvas"></canvas>

      <div id="info"><div id="score">Kompyuta: 0 | Wewe: 0</div></div>
      <div id="cardsInfo"><div id="cardsCount">K: 4 | M: 4</div></div>
      <div id="message"></div>
      <div id="hint">Tap kadi nyingi! Bonyeza top card kutupa!</div>

      <div id="winScreen">
        <div id="winText">UMESHINDA!</div>
        <button class="playAgain" onclick="startGame()">CHEZA TENA</button>
        <button class="backHome" onclick="goHome()">RUDI HOME</button>
      </div>

      <!-- Audio -->
      <audio id="shuffle" src="sounds/shuffle.ogg" preload="auto"></audio>
      <audio id="pick" src="sounds/pick.ogg" preload="auto"></audio>
      <audio id="throw" src="sounds/throw.ogg" preload="auto"></audio>
      <audio id="badmove" src="sounds/badmove.ogg" preload="auto"></audio>
      <audio
        id="win"
        src="https://assets.mixkit.co/sfx/preview/mixkit-triumphant-game-winning-575.mp3"
        preload="auto"
      ></audio>
    </div>

    <script>
      /* ==================== SOCKET.IO LOBBY ==================== */
      const socket = io();               // connects to the same origin (server.js serves this file)
      let roomId = null;
      let isMyTurn = false;

      /* ---- UI ---- */
      document.getElementById('createBtn').onclick = () => socket.emit('createRoom');
      document.getElementById('showJoin').onclick = () => {
        document.getElementById('joinSection').style.display = 'block';
        document.getElementById('createBtn').style.display = 'none';
        document.getElementById('showJoin').style.display = 'none';
      };
      document.getElementById('joinBtn').onclick = () => {
        const code = document.getElementById('codeInput').value.trim().toUpperCase();
        if (code) socket.emit('joinRoom', code);
      };

      /* ---- SERVER RESPONSES ---- */
      socket.on('roomCreated', id => {
        roomId = id;
        document.getElementById('roomCode').innerHTML = `Code: <b>${id}</b><br>Share with friend!`;
      });
      socket.on('roomJoined', id => {
        roomId = id;
        document.getElementById('lobby').style.display = 'none';
        document.getElementById('game').style.display = 'block';
        startOnlineGame();               // <-- initialise the card game
      });
      socket.on('error', msg => alert(msg));
      socket.on('opponentLeft', () => {
        alert('Opponent left! Returning to lobby...');
        location.reload();
      });
      socket.on('gameStart', ({ youAreFirst }) => {
        isMyTurn = youAreFirst;
        showMessage(isMyTurn ? "ZAMUU YAKO!" : "Subiri mpinzani...", isMyTurn ? "#0f0" : "#ff0");
      });

      /* ---- MOVE RELAY ---- */
      function sendMove(move) {
        if (!roomId || !isMyTurn) return;
        socket.emit('move', { roomId, move });
      }
      socket.on('opponentMove', handleOpponentMove);

      /* ==================== FULL ORIGINAL GAME CODE ==================== */
      (() => {
        // -----------------------------------------------------------------
        // ------------------- ALL ORIGINAL KADI 254 CODE ------------------
        // -----------------------------------------------------------------
        const canvas = document.getElementById("canvas");
        const ctx = canvas.getContext("2d");
        const scoreEl = document.getElementById("score");
        const cardsCountEl = document.getElementById("cardsCount");
        const messageEl = document.getElementById("message");
        const hintEl = document.getElementById("hint");
        const winScreen = document.getElementById("winScreen");
        const winText = document.getElementById("winText");

        let CARD_W = 120, CARD_H = 174;
        let DECK_X, DECK_Y, TOPCARD_X, TOPCARD_Y, USER_Y, OPP_Y;
        let BUTTON_X, BUTTON_Y, BUTTON_W, BUTTON_H;
        BUTTON_W = 100; BUTTON_H = 40;

        let playerScore = 0;
        let computerScore = 0;

        let topCardOffset = { x: 0, y: 0, rot: 0 };
        const deckScatterOffsets = [
          { x: 0, y: 0, rot: 0 },
          { x: 12, y: 8, rot: -0.15 },
          { x: -8, y: 15, rot: 0.12 },
          { x: 18, y: -5, rot: -0.08 },
          { x: -15, y: 22, rot: 0.2 },
        ];
        const playedPileOffsets = [
          { x: 0, y: 0, rot: 0.05 },
          { x: -18, y: 12, rot: -0.22 },
          { x: 25, y: -8, rot: 0.18 },
          { x: -12, y: 25, rot: -0.15 },
          { x: 20, y: 15, rot: 0.25 },
        ];

        function resize() {
          canvas.width = innerWidth;
          canvas.height = innerHeight;
          CARD_W = Math.min(innerWidth * 0.09, 65);
          CARD_H = CARD_W * 1.45;
          DECK_X = canvas.width * 0.2 - CARD_W * 1.2;
          DECK_Y = canvas.height * 0.5 - CARD_H * 0.5;
          TOPCARD_X = canvas.width * 0.5 - CARD_W * 0.5;
          TOPCARD_Y = canvas.height * 0.5 - CARD_H * 0.5;
          USER_Y = canvas.height - CARD_H - 20;
          OPP_Y = 20;
          BUTTON_X = canvas.width - 130;
          BUTTON_Y = 20;
        }
        window.addEventListener("resize", resize);
        resize();

        const deckBack = new Image(); deckBack.src = "images/back_side.png";
        const oppBack = new Image(); oppBack.src = "images/back_side.png";
        const suits = ["clubs", "diamonds", "hearts", "spades"];
        const cardImages = {};
        for (let s = 0; s < 4; s++) {
          for (let n = 0; n < 13; n++) {
            const imgNum = n===0?"1":n===9?"10":n===10?"11":n===11?"12":n===12?"13":`${n+1}`;
            const img = new Image();
            img.src = `images/${imgNum}_of_${suits[s]}.png`;
            cardImages[`${n}_${s}`] = img;
          }
        }

        let gameState = "loading";
        let animationCards = [];
        let animationProgress = 0;
        let animationTimer = 0;
        let dealCounter = 0;
        let allCards = [], userCards = [], opponentCards = [], staleCards = [], topCard = null;
        let recentPlayedCards = [];
        let myTurn = false, shouldEat = false, gameDone = false, isAnimating = false, gameReady = false;
        let dragCard = null;

        function shuffle(a){for(let i=a.length-1;i>0;i--){const j=Math.floor(Math.random()*(i+1));[a[i],a[j]]=[a[j],a[i]];}return a;}
        function playSound(id){try{document.getElementById(id).currentTime=0;document.getElementById(id).play();}catch(e){}}
        function vibrate(){navigator.vibrate?.([150,80,150]);}
        function updateScore(){
          scoreEl.innerHTML = `<span style="color:#ff0">Mpinzani: ${computerScore}</span> | <span style="color:#0f0">Wewe: ${playerScore}</span>`;
          if(cardsCountEl) cardsCountEl.innerHTML = `K: ${opponentCards.length} | M: ${userCards.length}`;
        }
        function showMessage(txt,color="#0f0",time=0){
          messageEl.textContent=txt;
          messageEl.style.borderColor=color;
          if(time>0){clearTimeout(window.msgTimeout);window.msgTimeout=setTimeout(()=>{messageEl.textContent="";},time);}
        }
        function showHint(show=true){
          if(show && myTurn && !gameDone && gameState==="ready"){hintEl.classList.add("show");}
          else{hintEl.classList.remove("show");}
        }

        function drawCard(card,x,y,scale=1,glow=false,angle=0,isBack=false){
          ctx.save();
          ctx.translate(x+(CARD_W*scale)/2,y+(CARD_H*scale)/2);
          ctx.rotate(angle);
          if(glow){ctx.shadowColor="#00ffff";ctx.shadowBlur=80;}
          const img = isBack?oppBack:cardImages[`${card.num}_${card.suit}`]||oppBack;
          try{ctx.drawImage(img,(-CARD_W*scale)/2,(-CARD_H*scale)/2,CARD_W*scale,CARD_H*scale);}
          catch(e){ctx.fillStyle="#333";ctx.fillRect((-CARD_W*scale)/2,(-CARD_H*scale)/2,CARD_W*scale,CARD_H*scale);}
          ctx.restore();
        }
        function drawScatteredDeck(x,y){
          ctx.shadowColor="#00ff00";ctx.shadowBlur=25;ctx.shadowOffsetY=10;
          deckScatterOffsets.forEach((offset,i)=>{
            const drawX=x+offset.x, drawY=y+offset.y, scale=0.95-i*0.03;
            ctx.save();ctx.translate(drawX+(CARD_W*scale)/2,drawY+(CARD_H*scale)/2);ctx.rotate(offset.rot);
            ctx.drawImage(deckBack,-(CARD_W*scale)/2,-(CARD_H*scale)/2,CARD_W*scale,CARD_H*scale);
            ctx.restore();
          });
        }
        function drawRecentPlayed(){
          if(!recentPlayedCards.length) return;
          const numToShow=Math.min(recentPlayedCards.length,5);
          const recent=recentPlayedCards.slice(-numToShow);
          const baseX=TOPCARD_X, baseY=TOPCARD_Y;
          recent.forEach((card,i)=>{
            const offset=playedPileOffsets[i];
            const drawX=baseX+offset.x, drawY=baseY+offset.y, scale=1.0-i*0.04;
            ctx.save();ctx.translate(drawX+(CARD_W*scale)/2,drawY+(CARD_H*scale)/2);ctx.rotate(offset.rot);
            ctx.shadowColor="rgba(0,0,0,0.6)";ctx.shadowBlur=15;ctx.shadowOffsetX=5;ctx.shadowOffsetY=8;
            ctx.drawImage(cardImages[`${card.num}_${card.suit}`]||oppBack,-(CARD_W*scale)/2,-(CARD_H*scale)/2,CARD_W*scale,CARD_H*scale);
            ctx.restore();
          });
        }
        function drawFan(cards,baseY,isUser=true){
          if(!cards.length) return;
          const spacing=CARD_W*0.7;
          const totalW=(cards.length-1)*spacing+CARD_W;
          const startX=(canvas.width-totalW)/2;
          const inKadi=isUser&&cards.length===1&&canFinish(cards[0]);
          for(let i=0;i<cards.length;i++){
            const card=cards[i];
            const x=startX+i*spacing;
            const dy=isUser?(card.float?-35:0)+(card.ready?-50:0):0;
            const angle=(i-(cards.length-1)/2)*(isUser?0.1:-0.08);
            const scale=isUser?1.0:0.85;
            if(inKadi){
              const pulse=Math.sin(Date.now()/300)*0.5+0.5;
              ctx.shadowColor=`rgba(255,${Math.floor(pulse*100)},0,${0.8+pulse*0.2})`;
              ctx.shadowBlur=50+pulse*30;
            }else{
              ctx.shadowColor=card.ready?"#00ffff":"rgba(0,255,255,0.5)";
              ctx.shadowBlur=card.ready?70:30;
            }
            ctx.shadowOffsetY=15;
            drawCard(card,x,baseY+dy,scale,card.ready||inKadi,angle,!isUser);
          }
        }

        function updateAnimation(){
          animationTimer++; animationProgress+=0.05;
          if(gameState==="reshuffling"){/* ... same as original ... */ /* omitted for brevity – copy from your original file */}
          else if(gameState==="dealing"){/* ... same ... */}
          else if(gameState==="game_start"){/* ... same ... */}
        }

        function draw(){
          updateAnimation();
          ctx.clearRect(0,0,canvas.width,canvas.height);
          ctx.fillStyle="#001a00"; ctx.fillRect(0,0,canvas.width,canvas.height);
          if(gameState==="dealing"||gameState==="game_start"||gameState==="ready") drawScatteredDeck(DECK_X,DECK_Y);
          animationCards.forEach(animCard=>{/* draw animCard – same as original */});
          if(gameState==="dealing"||gameState==="game_start"||gameState==="ready"){
            drawFan(opponentCards,OPP_Y,false);
            drawFan(userCards,USER_Y,true);
          }
          if(gameState==="ready"){
            drawRecentPlayed();
            ctx.shadowColor="#ffff00";ctx.shadowBlur=80;ctx.shadowOffsetY=15;
            if(topCard) drawCard(topCard,TOPCARD_X,TOPCARD_Y,1.15,true);
          }
          if(isAnimating && window.animCards){/* animation of thrown cards – same */ }
          ctx.fillStyle=gameState==="ready"?"#0f0":"#888";
          ctx.fillRect(BUTTON_X,BUTTON_Y,BUTTON_W,BUTTON_H);
          ctx.fillStyle="#000"; ctx.font="bold 20px Poppins"; ctx.textAlign="center"; ctx.textBaseline="middle";
          ctx.fillText("Restart",BUTTON_X+BUTTON_W/2,BUTTON_Y+BUTTON_H/2);
          ctx.textAlign="left"; ctx.textBaseline="alphabetic";
          updateScore(); showHint(); requestAnimationFrame(draw);
        }

        function startGame(){
          playSound("shuffle");
          allCards=[];userCards=[];opponentCards=[];staleCards=[];topCard=null;recentPlayedCards=[];
          gameState="reshuffling";animationProgress=0;animationTimer=0;dealCounter=0;isAnimating=true;
          gameDone=false;gameReady=false;myTurn=false;shouldEat=false;
          winScreen.classList.remove("show");
          for(let s=0;s<4;s++)for(let n=0;n<13;n++) allCards.push({suit:s,num:n,float:false,ready:false});
          shuffle(allCards);
          animationCards=[];
          for(let i=0;i<10;i++) animationCards.push({x:DECK_X+CARD_W/2,y:DECK_Y+CARD_H/2,dx:(Math.random()-0.5)*6,dy:(Math.random()-0.5)*6,rot:(Math.random()-0.5)*Math.PI,drot:(Math.random()-0.5)*0.05,scale:0.8,alpha:1});
        }

        function dropCards(cards,isUser){
          if(!isValid(topCard,cards,shouldEat)){playSound("badmove");vibrate();showMessage("HAPANA! Si halali!","#f00",3000);userCards.forEach(c=>c.ready=false);return;}
          isAnimating=true; window.animCards=cards.map(c=>({...c})); window.animIsUser=isUser;
          const arr=isUser?userCards:opponentCards;
          const firstIdx=arr.findIndex(c=>c.suit===cards[0].suit&&c.num===cards[0].num);
          const spacing=CARD_W*0.55; const totalW=(arr.length-1)*spacing+CARD_W;
          const startX=(canvas.width-totalW)/2;
          window.animFromX=startX+firstIdx*spacing; window.animFromY=isUser?USER_Y:OPP_Y;
          window.animToX=TOPCARD_X; window.animToY=TOPCARD_Y; window.animStep=0;
          playSound("throw"); showMessage(isUser?"Poa sana!":"Mpinzani ametupa!","#0f0");
          setTimeout(()=>{
            if(topCard) recentPlayedCards.push(topCard);
            cards.forEach(c=>recentPlayedCards.push(c)); recentPlayedCards=recentPlayedCards.slice(-5);
            staleCards.push(topCard,...cards.slice(0,-1));
            topCard=cards[cards.length-1];
            if(isUser){userCards=userCards.filter(c=>!cards.some(dc=>dc.suit===c.suit&&dc.num===c.num));userCards.forEach(c=>{c.ready=false;c.float=false;});}
            else opponentCards=opponentCards.filter(c=>!cards.some(dc=>dc.suit===c.suit&&dc.num===c.num));
            const feeder=[1,2].includes(topCard.num);
            if(isQuestion(topCard)){showMessage("FUNIKA HII KADI!","#ff0");}
            else if(feeder){showMessage(topCard.num===1?"KULA 2!":"KULA 3!","#f00");shouldEat=true;myTurn=!isUser;}
            else{shouldEat=false;myTurn=!isUser;showMessage(myTurn?"Zamuu yako!":"Mpinzani anacheza...",myTurn?"#0f0":"#ff0",2000);}
            if(!myTurn) setTimeout(opponentTurn,700);
            checkGameOver(); isAnimating=false;
          },900);
        }

        function pickCards(num,isUser){
          if(isAnimating||gameState!=="ready") return;
          isAnimating=true; window.animCards=[];
          for(let i=0;i<num&&allCards.length>0;i++) window.animCards.push(allCards.pop());
          const spacing=CARD_W*0.55;
          const totalW=((isUser?userCards.length:opponentCards.length)+num-1)*spacing+CARD_W;
          const startX=(canvas.width-totalW)/2;
          const base=isUser?userCards.length:opponentCards.length;
          window.animFromX=DECK_X; window.animFromY=DECK_Y;
          window.animToX=startX+base*spacing; window.animToY=isUser?USER_Y:OPP_Y;
          window.animStep=0; playSound("pick");
          showMessage(isUser?"Umechukua!":"Mpinzani anachukua","#fff");
          setTimeout(()=>{
            if(isUser) userCards.push(...window.animCards.map(c=>({...c,float:false,ready:false})));
            else opponentCards.push(...window.animCards.map(c=>({...c})));
            isAnimating=false; shouldEat=false; myTurn=!isUser;
            messageEl.textContent=""; showMessage(myTurn?"Zamuu yako!":"Subiri kidogo...",myTurn?"#0f0":"#ff0",2000);
            if(!myTurn) setTimeout(opponentTurn,800);
            checkGameOver();
          },900);
        }

        function isQuestion(card){return [7,10,11,12].includes(card.num);}
        function canFinish(card){return ![0,1,2,7,10,11,12].includes(card.num);}
        function isValid(top,cards,eat){
          if(!cards.length) return false;
          let prev=top;
          for(let i=0;i<cards.length;i++){
            const c=cards[i], first=i===0;
            if(eat){
              if(first){if(c.num!==prev.num && c.num!==0) return false;}
              else if(c.num!==prev.num) return false;
            }else if(!first){
              if(isQuestion(prev)){
                if(!(c.suit===prev.suit||c.num===prev.num||c.num===0)) return false;
              }else if(c.num!==prev.num) return false;
            }else if(!(c.suit===prev.suit||c.num===prev.num||c.num===0)) return false;
            prev=c;
          }
          return true;
        }

        function opponentTurn(){
          if(gameDone||myTurn||isAnimating||gameState!=="ready") return;
          showMessage("Mpinzani anacheza...","#ff0");
          setTimeout(()=>{
            const best=findBestMoves(topCard,opponentCards,shouldEat);
            if(best.length===0){
              const num=shouldEat?(topCard.num===1?2:3):1;
              pickCards(num,false);
            }else{
              dropCards(best,false);
            }
          },700+Math.random()*500);
        }

        function findBestMoves(top,cards,eat){
          const allMoves=[];
          function rec(cur,rem,path){
            if(path.length) allMoves.push([...path]);
            const nexts=rem.filter(c=>{
              if(eat) return c.num===cur.num||c.num===0;
              else if(path.length){
                if(isQuestion(cur)) return c.suit===cur.suit||c.num===cur.num||c.num===0;
                else return c.num===cur.num;
              }else return c.suit===cur.suit||c.num===cur.num||c.num===0;
            });
            for(let nc of nexts){
              const newRem=rem.filter(c=>!(c.suit===nc.suit&&c.num===nc.num));
              rec(nc,newRem,[...path,nc]);
            }
          }
          rec(top,cards,[]);
          let best=[],bestScore=-99999;
          for(let m of allMoves){
            const remain=cards.filter(c=>!m.some(x=>x.suit===c.suit&&x.num===c.num));
            let score=-remain.length*50;
            const counts={}; remain.forEach(c=>counts[c.num]=(counts[c.num]||0)+1);
            Object.values(counts).forEach(c=>c>1?score+=(c-1)*10:null);
            if(remain.length===0&&canFinish(m[m.length-1])) score=99999;
            if(score>bestScore){bestScore=score;best=m;}
          }
          if(best.length===1&&isQuestion(best[0])&&Math.random()<0.25) best=[];
          return best;
        }

        function checkGameOver(){
          if(userCards.length===0&&canFinish(topCard)&&opponentCards.length>0){
            playerScore++; winText.textContent="UMESHINDA!!!"; winText.style.color="#0f0";
            winScreen.classList.add("show"); confetti({particleCount:600,spread:140,origin:{y:0.55}});
            playSound("win"); gameDone=true; updateScore();
          }
          if(opponentCards.length===0&&canFinish(topCard)&&userCards.length>0){
            computerScore++; winText.textContent="MPINZANI AMESHINDA!"; winText.style.color="#f00";
            winScreen.classList.add("show"); gameDone=true; updateScore();
          }
        }

        function getHit(x,y){
          const spacing=CARD_W*0.7;
          const totalW=(userCards.length-1)*spacing+CARD_W;
          const startX=(canvas.width-totalW)/2;
          for(let i=userCards.length-1;i>=0;i--){
            const card=userCards[i];
            const cx=startX+i*spacing;
            const dy=(card.float?-35:0)+(card.ready?-50:0);
            const left=cx+CARD_W*0.1, right=cx+CARD_W*0.9;
            if(x>left&&x<right&&y>USER_Y+dy-60&&y<USER_Y+dy+CARD_H+60) return {type:"user",idx:i};
          }
          if(x>DECK_X-30&&x<DECK_X+CARD_W+30&&y>DECK_Y-30&&y<DECK_Y+CARD_H+30) return {type:"deck"};
          if(x>canvas.width*0.3&&x<canvas.width*0.7&&y>canvas.height*0.3&&y<canvas.height*0.7) return {type:"top"};
          if(x>BUTTON_X&&x<BUTTON_X+BUTTON_W&&y>BUTTON_Y&&y<BUTTON_Y+BUTTON_H) return {type:"restart"};
          return null;
        }
        function getInputXY(e){
          const rect=canvas.getBoundingClientRect();
          const clientX = e.touches?e.touches[0].clientX:e.clientX;
          const clientY = e.touches?e.touches[0].clientY:e.clientY;
          return {x:(clientX-rect.left)*(canvas.width/rect.width), y:(clientY-rect.top)*(canvas.height/rect.height)};
        }
        function handleStart(x,y){
          if(!myTurn||isAnimating||gameDone||gameState!=="ready") return;
          const hit=getHit(x,y);
          if(hit?.type==="user"){
            dragCard={card:userCards[hit.idx],idx:hit.idx,x:x-CARD_W/2,y:y-CARD_H/2};
            userCards[hit.idx].float=true;
          }
        }
        function handleMove(x,y){
          if(!dragCard) return;
          dragCard.x=x-CARD_W/2; dragCard.y=y-CARD_H/2;
        }
        function handleEnd(x,y){
          const hit=getHit(x,y);
          if(hit?.type==="restart"){startGame();return;}
          if(!myTurn||isAnimating||gameDone||gameState!=="ready") return;
          if(hit?.type==="deck"){
            const num=shouldEat?(topCard.num===1?2:3):1;
            pickCards(num,true);
            userCards.forEach(c=>c.float=false); dragCard=null; return;
          }
          if(hit?.type==="top"){
            const ready=userCards.filter(c=>c.ready);
            if(ready.length>0) dropCards(ready.map(c=>({suit:c.suit,num:c.num})),true);
            else showMessage("Chagua kadi ya kutupa!","#ff0");
            userCards.forEach(c=>c.float=false); dragCard=null; return;
          }
          if(dragCard){
            const dx=x-(dragCard.x+CARD_W/2);
            if(Math.abs(dx)>70){
              const dir=dx>0?1:-1;
              const newIdx=dragCard.idx+dir;
              if(newIdx>=0&&newIdx<userCards.length) [userCards[dragCard.idx],userCards[newIdx]]=[userCards[newIdx],userCards[dragCard.idx]];
            }else userCards[dragCard.idx].ready=!userCards[dragCard.idx].ready;
          }
          userCards.forEach(c=>c.float=false); dragCard=null;
        }

        canvas.addEventListener("touchstart",e=>{e.preventDefault();const p=getInputXY(e);handleStart(p.x,p.y);},{passive:false});
        canvas.addEventListener("touchmove",e=>{e.preventDefault();const p=getInputXY(e);handleMove(p.x,p.y);},{passive:false});
        canvas.addEventListener("touchend",e=>{e.preventDefault();const p=getInputXY(e);handleEnd(p.x,p.y);},{passive:false});
        canvas.addEventListener("mousedown",e=>{e.preventDefault();const p=getInputXY(e);handleStart(p.x,p.y);});
        canvas.addEventListener("mousemove",e=>{const p=getInputXY(e);handleMove(p.x,p.y);});
        canvas.addEventListener("mouseup",e=>{const p=getInputXY(e);handleEnd(p.x,p.y);});

        /* -----------------------------------------------------------------
           ONLINE-SPECIFIC WRAPPERS
           ----------------------------------------------------------------- */
        function startOnlineGame(){
          // Reset everything as if we pressed "Restart"
          startGame();
          // The server already told us who starts via `gameStart`
          // We just wait for the first turn flag (`isMyTurn`)
        }

        // ---------- SEND USER ACTIONS ----------
        const originalDropCards = dropCards;
        dropCards = function(cards, isUser){
          if(!isUser) return originalDropCards.apply(this, arguments); // opponent move (handled below)
          // Send to server
          sendMove({type:'drop', cards:cards.map(c=>({suit:c.suit,num:c.num}))});
          // Continue local animation (optimistic UI)
          originalDropCards.call(this, cards, true);
        };

        const originalPickCards = pickCards;
        pickCards = function(num, isUser){
          if(!isUser) return originalPickCards.apply(this, arguments);
          sendMove({type:'pick', num});
          originalPickCards.call(this, num, true);
        };

        // ---------- RECEIVE OPPONENT ACTIONS ----------
        function handleOpponentMove(move){
          if(move.type==='drop'){
            const cards = move.cards.map(c=>({suit:c.suit,num:c.num,float:false,ready:false}));
            originalDropCards(cards, false);
          }else if(move.type==='pick'){
            originalPickCards(move.num, false);
          }
        }

        // Turn management – after a move we flip `isMyTurn` locally (same as original logic)
        const oldDropTimeout = /* the setTimeout inside dropCards that flips myTurn */;
        // (the original code already flips `myTurn` after animation – we keep that)

        // -----------------------------------------------------------------
        // IMAGE PRE-LOAD (same as original)
        // -----------------------------------------------------------------
        let loaded = 0;
        const expected = Object.keys(cardImages).length + 2;
        function imgLoaded(){ loaded++; if(loaded>=expected){ resize(); draw(); } }
        deckBack.onload=imgLoaded; oppBack.onload=imgLoaded;
        Object.values(cardImages).forEach(img=>img.onload=imgLoaded);

        // Fallback if images are cached
        setTimeout(()=>{ if(gameState==="loading"){ resize(); draw(); } },1500);
      })();
    </script>

    <script>
      function goHome() {
        window.location.href = "index.html";
      }
    </script>
  </body>
</html>
