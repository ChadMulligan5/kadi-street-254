<!DOCTYPE html>
<html lang="sw">
  <head>
    <meta charset="UTF-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"
    />
    <title>KADI 254 - Online</title>
    <script src="https://cdn.socket.io/4.7.2/socket.io.min.js"></script>
    <link
      href="https://fonts.googleapis.com/css2?family=Bangers&family=Poppins:wght@700;900&display=swap"
      rel="stylesheet"
    />
    <script src="https://cdn.jsdelivr.net/npm/canvas-confetti@1.9.2/dist/confetti.browser.min.js"></script>
    <style>
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }
      body {
        background: #000;
        font-family: "Poppins", sans-serif;
        overflow: hidden;
        height: 100vh;
        color: #fff;
        touch-action: none;
      }

      #nameModal {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.95);
        display: flex;
        justify-content: center;
        align-items: center;
        z-index: 2000;
      }
      #nameModal.hidden {
        display: none;
      }
      .modal-content {
        background: linear-gradient(135deg, #1a1a1a, #000);
        border: 4px solid #0f0;
        border-radius: 20px;
        padding: 40px;
        text-align: center;
        box-shadow: 0 0 50px rgba(0, 255, 0, 0.5);
        max-width: 400px;
        width: 90%;
      }
      .modal-content h2 {
        font-family: "Bangers";
        font-size: 2.5rem;
        color: #0f0;
        margin-bottom: 20px;
        text-shadow: 0 0 20px #0f0;
      }
      .modal-content input {
        width: 100%;
        padding: 15px;
        font-size: 1.3rem;
        text-align: center;
        border: 3px solid #0f0;
        border-radius: 15px;
        background: #111;
        color: #0f0;
        margin-bottom: 20px;
        font-family: "Poppins", sans-serif;
      }
      .modal-content input:focus {
        outline: none;
        box-shadow: 0 0 20px rgba(0, 255, 0, 0.5);
      }

      #lobby,
      #game {
        width: 100%;
        height: 100%;
        position: absolute;
        top: 0;
        left: 0;
      }
      #lobby {
        background: linear-gradient(135deg, #000, #1a1a1a);
        color: #0f0;
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        gap: 20px;
        text-align: center;
      }
      #lobby h1 {
        font-family: "Bangers";
        font-size: 4rem;
        color: #0f0;
        text-shadow: 0 0 20px #0f0;
      }
      .btn {
        padding: 15px 40px;
        font-size: 1.5rem;
        background: #0f0;
        color: #000;
        border: none;
        border-radius: 50px;
        cursor: pointer;
        font-weight: 900;
        transition: all 0.3s;
      }
      .btn:hover {
        transform: scale(1.05);
        box-shadow: 0 0 30px #0f0;
      }
      #showJoin {
        background: #ff0;
        color: #000;
      }
      #joinSection {
        display: none;
        gap: 10px;
        flex-direction: column;
        align-items: center;
      }
      #codeInput {
        padding: 15px;
        font-size: 1.5rem;
        width: 200px;
        text-align: center;
        border: 3px solid #0f0;
        border-radius: 15px;
        background: #111;
        color: #0f0;
      }
      #roomCode {
        font-size: 3rem;
        font-family: "Bangers";
        letter-spacing: 5px;
      }
      #game {
        display: none;
      }
      #info {
        position: absolute;
        top: 15px;
        left: 15px;
        z-index: 100;
        background: rgba(0, 0, 0, 0.85);
        padding: 10px 18px;
        border-radius: 15px;
        border: 3px solid #0f0;
        box-shadow: 0 0 25px rgba(0, 255, 0, 0.6);
        font-family: "Bangers";
        font-size: 1.6rem;
      }
      #playerNames {
        position: absolute;
        top: 15px;
        right: 15px;
        z-index: 100;
        background: rgba(0, 0, 0, 0.85);
        padding: 10px 18px;
        border-radius: 15px;
        border: 3px solid #0ff;
        box-shadow: 0 0 25px rgba(0, 255, 255, 0.6);
        font-family: "Poppins";
        font-size: 1rem;
        text-align: right;
      }
      #cardsInfo {
        position: absolute;
        bottom: 15px;
        left: 15px;
        z-index: 100;
        background: rgba(0, 0, 0, 0.75);
        padding: 8px 15px;
        border-radius: 12px;
        border: 2px solid #0ff;
        font-size: 0.9rem;
        color: #0ff;
      }
      #message {
        position: absolute;
        top: 20px;
        right: 20px;
        z-index: 150;
        background: rgba(0, 0, 0, 0.95);
        padding: 12px 30px;
        border-radius: 20px;
        border: 4px solid #ff0;
        font-family: "Bangers";
        font-size: 1.8rem;
        text-align: center;
        animation: pop 0.4s;
        pointer-events: none;
        box-shadow: 0 0 40px rgba(255, 255, 0, 0.8);
        max-width: 300px;
      }
      #hint {
        position: absolute;
        bottom: 15px;
        left: 15px;
        z-index: 100;
        background: rgba(0, 0, 0, 0.9);
        padding: 8px 16px;
        border-radius: 12px;
        border: 2px solid #0ff;
        font-size: 0.85rem;
        color: #0ff;
        opacity: 0;
        transition: opacity 0.3s;
        max-width: 250px;
      }
      #hint.show {
        opacity: 1;
      }
      #winScreen {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.98);
        display: none;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        z-index: 1000;
      }
      #winScreen.show {
        display: flex;
      }
      #winText {
        font-family: "Bangers";
        font-size: 6rem;
        text-shadow: 0 0 40px #0f0;
        margin-bottom: 40px;
      }
      .playAgain {
        padding: 25px 90px;
        font-size: 2.3rem;
        background: #0f0;
        color: #000;
        border: none;
        border-radius: 60px;
        cursor: pointer;
        font-weight: 900;
        transition: all 0.3s;
      }
      .playAgain:hover {
        transform: scale(1.05);
        box-shadow: 0 0 40px #0f0;
      }
      .backHome {
        margin-top: 20px;
        padding: 15px 50px;
        font-size: 1.5rem;
        background: transparent;
        color: #fff;
        border: 3px solid #fff;
        border-radius: 40px;
        cursor: pointer;
        font-weight: 700;
        transition: all 0.3s;
      }
      .backHome:hover {
        background: #fff;
        color: #000;
      }
      @keyframes pop {
        0% {
          opacity: 0;
          transform: scale(0.8);
        }
        100% {
          opacity: 1;
          transform: scale(1);
        }
      }
      @media (max-width: 768px) {
        #lobby h1 {
          font-size: 3rem;
        }
        .modal-content h2 {
          font-size: 2rem;
        }
        #info {
          font-size: 1.3rem;
          padding: 8px 15px;
        }
        #message {
          top: 80px;
          right: 10px;
          left: 10px;
          font-size: 1.4rem;
          padding: 10px 20px;
          max-width: none;
        }
        #winText {
          font-size: 3.5rem;
        }
        .playAgain {
          padding: 20px 60px;
          font-size: 1.8rem;
        }
      }
    </style>
  </head>
  <body>
    <div id="nameModal">
      <div class="modal-content">
        <h2>JINA LAKO?</h2>
        <input
          id="playerNameInput"
          type="text"
          placeholder="Weka jina lako..."
          maxlength="20"
        />
        <button class="btn" id="confirmNameBtn">ENDELEA</button>
      </div>
    </div>

    <div id="lobby">
      <h1>KADI 254</h1>
      <button class="btn" id="createBtn">CREATE ROOM</button>
      <div id="joinSection">
        <input id="codeInput" placeholder="Enter Code" />
        <button class="btn" id="joinBtn">JOIN</button>
      </div>
      <div id="roomCode"></div>
      <button class="btn" id="showJoin">Join Existing Room</button>
    </div>

    <div id="game">
      <canvas id="canvas"></canvas>
      <div id="info"><div id="score">Mpinzani: 0 | Wewe: 0</div></div>
      <div id="playerNames">
        <div id="opponentName" style="color: #ff0">Opponent</div>
        <div id="yourName" style="color: #0f0">You</div>
      </div>
      <div id="cardsInfo"><div id="cardsCount">K: 0 | M: 0</div></div>
      <div id="message"></div>
      <div id="hint">Tap kadi nyingi! Bonyeza top card kutupa!</div>
      <div id="winScreen">
        <div id="winText">UMESHINDA!</div>
        <button class="playAgain" id="playAgainBtn">CHEZA TENA</button>
        <button class="backHome" onclick="goHome()">RUDI HOME</button>
      </div>
      <audio id="shuffle" src="sounds/shuffle.ogg" preload="auto"></audio>
      <audio id="pick" src="sounds/pick.ogg" preload="auto"></audio>
      <audio id="throw" src="sounds/throw.ogg" preload="auto"></audio>
      <audio id="badmove" src="sounds/badmove.ogg" preload="auto"></audio>
      <audio
        id="win"
        src="https://assets.mixkit.co/sfx/preview/mixkit-triumphant-game-winning-575.mp3"
        preload="auto"
      ></audio>
    </div>

    <script>
      let playerName = "";
      document
        .getElementById("confirmNameBtn")
        .addEventListener("click", () => {
          const input = document.getElementById("playerNameInput").value.trim();
          if (input.length >= 2) {
            playerName = input;
            document.getElementById("nameModal").classList.add("hidden");
            document.getElementById("lobby").style.display = "flex";
          } else {
            alert("Tafadhali weka jina la kweli (angalau herufi 2)!");
          }
        });
      document
        .getElementById("playerNameInput")
        .addEventListener("keypress", (e) => {
          if (e.key === "Enter")
            document.getElementById("confirmNameBtn").click();
        });

      const socket = io();
      let roomId = null,
        isMyTurn = false,
        myTurn = false,
        opponentName = "";

      document.getElementById("createBtn").onclick = () => {
        if (!playerName) {
          alert("Weka jina lako kwanza!");
          return;
        }
        socket.emit("createRoom", { playerName });
      };
      document.getElementById("showJoin").onclick = () => {
        if (!playerName) {
          alert("Weka jina lako kwanza!");
          return;
        }
        document.getElementById("joinSection").style.display = "flex";
        document.getElementById("createBtn").style.display = "none";
        document.getElementById("showJoin").style.display = "none";
      };
      document.getElementById("joinBtn").onclick = () => {
        if (!playerName) {
          alert("Weka jina lako kwanza!");
          return;
        }
        const code = document
          .getElementById("codeInput")
          .value.trim()
          .toUpperCase();
        if (code) socket.emit("joinRoom", { code, playerName });
      };

      socket.on("roomCreated", (id) => {
        roomId = id;
        document.getElementById(
          "roomCode"
        ).innerHTML = `Code: <b>${id}</b><br>Share with friend!`;
      });
      socket.on("roomJoined", ({ id, opponentName: oppName }) => {
        roomId = id;
        opponentName = oppName;
      });
      socket.on("error", (msg) => alert(msg));
      socket.on("opponentLeft", () => {
        alert("Opponent left! Returning to lobby...");
        location.reload();
      });
      socket.on(
        "gameStart",
        ({
          youAreFirst,
          deck,
          userHand,
          opponentHandCount,
          topCard,
          opponentName: oppName,
        }) => {
          isMyTurn = youAreFirst;
          opponentName = oppName;
          document.getElementById("lobby").style.display = "none";
          document.getElementById("game").style.display = "block";
          document.getElementById("yourName").textContent = playerName;
          document.getElementById("opponentName").textContent = opponentName;
          initGameFromServer(deck, userHand, opponentHandCount, topCard);
        }
      );
      socket.on("opponentMove", (move) => {
        if (move.type === "drop") {
          const cards = move.cards.map((c) => ({
            suit: c.suit,
            num: c.num,
            float: false,
            ready: false,
          }));
          window.dropCardsLocal(cards, false);
        } else if (move.type === "pick") {
          window.pickCardsLocal(move.cards, false);
        }
      });
      socket.on("deckUpdate", ({ remainingCards }) => {
        window.updateDeck(remainingCards);
      });

      function sendMove(move) {
        if (!roomId || !myTurn) return;
        socket.emit("move", { roomId, move });
      }

      (() => {
        const canvas = document.getElementById("canvas");
        const ctx = canvas.getContext("2d");
        const scoreEl = document.getElementById("score");
        const cardsCountEl = document.getElementById("cardsCount");
        const messageEl = document.getElementById("message");
        const hintEl = document.getElementById("hint");
        const winScreen = document.getElementById("winScreen");
        const winText = document.getElementById("winText");

        let CARD_W = 120,
          CARD_H = 174;
        let DECK_X, DECK_Y, TOPCARD_X, TOPCARD_Y, USER_Y, OPP_Y;
        let BUTTON_X,
          BUTTON_Y,
          BUTTON_W = 100,
          BUTTON_H = 40;
        let playerScore = 0,
          computerScore = 0;

        const deckScatterOffsets = [
          { x: 0, y: 0, rot: 0 },
          { x: 12, y: 8, rot: -0.15 },
          { x: -8, y: 15, rot: 0.12 },
          { x: 18, y: -5, rot: -0.08 },
          { x: -15, y: 22, rot: 0.2 },
        ];
        const playedPileOffsets = [
          { x: 0, y: 0, rot: 0.05 },
          { x: -18, y: 12, rot: -0.22 },
          { x: 25, y: -8, rot: 0.18 },
          { x: -12, y: 25, rot: -0.15 },
          { x: 20, y: 15, rot: 0.25 },
        ];

        let gameState = "loading";
        let animationCards = [],
          animationTimer = 0,
          dealCounter = 0;
        let allCards = [],
          userCards = [],
          opponentCards = [],
          topCard = null;
        let recentPlayedCards = [];
        let shouldEat = false,
          gameDone = false,
          isAnimating = false;
        let dragCard = null;

        function resize() {
          canvas.width = innerWidth;
          canvas.height = innerHeight;
          CARD_W = Math.min(innerWidth * 0.09, 65);
          CARD_H = CARD_W * 1.45;
          DECK_X = canvas.width * 0.2 - CARD_W * 1.2;
          DECK_Y = canvas.height * 0.5 - CARD_H * 0.5;
          TOPCARD_X = canvas.width * 0.5 - CARD_W * 0.5;
          TOPCARD_Y = canvas.height * 0.5 - CARD_H * 0.5;
          USER_Y = canvas.height - CARD_H - 20;
          OPP_Y = 20;
          BUTTON_X = canvas.width - 130;
          BUTTON_Y = 20;
        }
        window.addEventListener("resize", resize);
        resize();

        const deckBack = new Image();
        deckBack.src = "images/back_side.png";
        const oppBack = new Image();
        oppBack.src = "images/back_side.png";
        const suits = ["clubs", "diamonds", "hearts", "spades"];
        const cardImages = {};
        for (let s = 0; s < 4; s++) {
          for (let n = 0; n < 13; n++) {
            const imgNum =
              n === 0
                ? "1"
                : n === 9
                ? "10"
                : n === 10
                ? "11"
                : n === 11
                ? "12"
                : n === 12
                ? "13"
                : `${n + 1}`;
            const img = new Image();
            img.src = `images/${imgNum}_of_${suits[s]}.png`;
            cardImages[`${n}_${s}`] = img;
          }
        }

        function playSound(id) {
          try {
            document.getElementById(id).currentTime = 0;
            document.getElementById(id).play();
          } catch (e) {}
        }
        function vibrate() {
          navigator.vibrate?.([150, 80, 150]);
        }

        function updateScore() {
          scoreEl.innerHTML = `<span style="color:#ff0">${opponentName}: ${computerScore}</span> | <span style="color:#0f0">${playerName}: ${playerScore}</span>`;
          cardsCountEl.innerHTML = `K: ${opponentCards.length} | M: ${userCards.length}`;
        }

        window.showMessage = function (txt, color = "#0f0", time = 0) {
          messageEl.textContent = txt;
          messageEl.style.borderColor = color;
          if (time > 0) {
            clearTimeout(window.msgTimeout);
            window.msgTimeout = setTimeout(
              () => (messageEl.textContent = ""),
              time
            );
          }
        };

        function showHint(show = true) {
          if (show && myTurn && !gameDone && gameState === "ready")
            hintEl.classList.add("show");
          else hintEl.classList.remove("show");
        }

        function drawCard(
          card,
          x,
          y,
          scale = 1,
          glow = false,
          angle = 0,
          isBack = false
        ) {
          ctx.save();
          ctx.translate(x + (CARD_W * scale) / 2, y + (CARD_H * scale) / 2);
          ctx.rotate(angle);
          if (glow) {
            ctx.shadowColor = "#00ffff";
            ctx.shadowBlur = 80;
          }
          const img = isBack
            ? oppBack
            : cardImages[`${card.num}_${card.suit}`] || oppBack;
          try {
            ctx.drawImage(
              img,
              (-CARD_W * scale) / 2,
              (-CARD_H * scale) / 2,
              CARD_W * scale,
              CARD_H * scale
            );
          } catch (e) {
            ctx.fillStyle = "#333";
            ctx.fillRect(
              (-CARD_W * scale) / 2,
              (-CARD_H * scale) / 2,
              CARD_W * scale,
              CARD_H * scale
            );
          }
          ctx.restore();
        }

        function drawScatteredDeck(x, y) {
          if (allCards.length === 0) return;
          ctx.shadowColor = "#00ff00";
          ctx.shadowBlur = 25;
          ctx.shadowOffsetY = 10;
          deckScatterOffsets.forEach((offset, i) => {
            const drawX = x + offset.x,
              drawY = y + offset.y,
              scale = 0.95 - i * 0.03;
            ctx.save();
            ctx.translate(
              drawX + (CARD_W * scale) / 2,
              drawY + (CARD_H * scale) / 2
            );
            ctx.rotate(offset.rot);
            ctx.drawImage(
              deckBack,
              -(CARD_W * scale) / 2,
              -(CARD_H * scale) / 2,
              CARD_W * scale,
              CARD_H * scale
            );
            ctx.restore();
          });
        }

        function drawRecentPlayed() {
          if (!recentPlayedCards.length) return;
          const numToShow = Math.min(recentPlayedCards.length, 5);
          const recent = recentPlayedCards.slice(-numToShow);
          const baseX = TOPCARD_X,
            baseY = TOPCARD_Y;
          recent.forEach((card, i) => {
            const offset = playedPileOffsets[i];
            const drawX = baseX + offset.x,
              drawY = baseY + offset.y,
              scale = 1.0 - i * 0.04;
            ctx.save();
            ctx.translate(
              drawX + (CARD_W * scale) / 2,
              drawY + (CARD_H * scale) / 2
            );
            ctx.rotate(offset.rot);
            ctx.shadowColor = "rgba(0,0,0,0.6)";
            ctx.shadowBlur = 15;
            ctx.shadowOffsetX = 5;
            ctx.shadowOffsetY = 8;
            ctx.drawImage(
              cardImages[`${card.num}_${card.suit}`] || oppBack,
              -(CARD_W * scale) / 2,
              -(CARD_H * scale) / 2,
              CARD_W * scale,
              CARD_H * scale
            );
            ctx.restore();
          });
        }

        function drawFan(cards, baseY, isUser = true) {
          if (!cards.length) return;
          const spacing = CARD_W * 0.7;
          const totalW = (cards.length - 1) * spacing + CARD_W;
          const startX = (canvas.width - totalW) / 2;
          const inKadi = isUser && cards.length === 1 && canFinish(cards[0]);
          for (let i = 0; i < cards.length; i++) {
            const card = cards[i];
            const x = startX + i * spacing;
            const dy = isUser
              ? (card.float ? -35 : 0) + (card.ready ? -50 : 0)
              : 0;
            const angle = (i - (cards.length - 1) / 2) * (isUser ? 0.1 : -0.08);
            const scale = isUser ? 1.0 : 0.85;
            const isHidden =
              !isUser && (card.suit === null || card.num === null);
            if (inKadi) {
              const pulse = Math.sin(Date.now() / 300) * 0.5 + 0.5;
              ctx.shadowColor = `rgba(255,${Math.floor(pulse * 100)},0,${
                0.8 + pulse * 0.2
              })`;
              ctx.shadowBlur = 50 + pulse * 30;
            } else {
              ctx.shadowColor = card.ready ? "#00ffff" : "rgba(0,255,255,0.5)";
              ctx.shadowBlur = card.ready ? 70 : 30;
            }
            ctx.shadowOffsetY = 15;
            drawCard(
              card,
              x,
              baseY + dy,
              scale,
              card.ready || inKadi,
              angle,
              isHidden
            );
          }
        }

        function draw() {
          animationTimer++;
          ctx.clearRect(0, 0, canvas.width, canvas.height);
          ctx.fillStyle = "#001a00";
          ctx.fillRect(0, 0, canvas.width, canvas.height);

          if (gameState !== "loading") {
            drawScatteredDeck(DECK_X, DECK_Y);
          }

          if (gameState === "ready") {
            drawFan(opponentCards, OPP_Y, false);
            drawFan(userCards, USER_Y, true);
            drawRecentPlayed();
            if (topCard) {
              ctx.shadowColor = "#ffff00";
              ctx.shadowBlur = 80;
              ctx.shadowOffsetY = 15;
              drawCard(topCard, TOPCARD_X, TOPCARD_Y, 1.15, true);
            }
          }

          if (isAnimating && window.animCards) {
            const progress = Math.min(window.animStep / 22, 1);
            const ease =
              progress < 0.5
                ? 2 * progress * progress
                : 1 - Math.pow(-2 * progress + 2, 2) / 2;
            const dx = window.animToX - window.animFromX;
            const dy = window.animToY - window.animFromY;
            window.animCards.forEach((c, i) => {
              const offsetX = i * 40;
              const offsetY = i * 25;
              const x = window.animFromX + dx * ease + offsetX * (1 - ease);
              const y = window.animFromY + dy * ease + offsetY * (1 - ease);
              const isHidden =
                !window.animIsUser && (c.suit === null || c.num === null);
              drawCard(c, x, y, 0.95, true, ease * 0.3, isHidden);
            });
            window.animStep++;
            if (progress >= 1) isAnimating = false;
          }

          ctx.fillStyle = gameState === "ready" ? "#0f0" : "#888";
          ctx.fillRect(BUTTON_X, BUTTON_Y, BUTTON_W, BUTTON_H);
          ctx.fillStyle = "#000";
          ctx.font = "bold 20px Poppins";
          ctx.textAlign = "center";
          ctx.textBaseline = "middle";
          ctx.fillText(
            "Restart",
            BUTTON_X + BUTTON_W / 2,
            BUTTON_Y + BUTTON_H / 2
          );

          updateScore();
          showHint();
          requestAnimationFrame(draw);
        }

        window.updateDeck = function (remainingCards) {
          allCards = remainingCards.map((c) => ({ suit: c.suit, num: c.num }));
        };

        window.initGameFromServer = function (
          deck,
          userHand,
          opponentHandCount,
          topCardData
        ) {
          playSound("shuffle");
          allCards = deck.map((c) => ({ suit: c.suit, num: c.num }));
          userCards = userHand.map((c) => ({
            ...c,
            float: false,
            ready: false,
          }));
          opponentCards = Array(opponentHandCount)
            .fill(null)
            .map(() => ({ suit: null, num: null }));
          topCard = { ...topCardData };
          recentPlayedCards = [];
          gameState = "ready";
          myTurn = isMyTurn;
          isAnimating = false;
          gameDone = false;
          shouldEat = false;
          winScreen.classList.remove("show");
          window.showMessage(
            myTurn ? "ZAMUU YAKO!" : "Subiri mpinzani...",
            myTurn ? "#0f0" : "#ff0"
          );
        };

        window.dropCardsLocal = function (cards, isUser) {
          if (!isValid(topCard, cards, shouldEat)) {
            if (isUser) {
              playSound("badmove");
              vibrate();
              window.showMessage("HAPANA! Si halali!", "#f00", 3000);
              userCards.forEach((c) => (c.ready = false));
            }
            return false;
          }
          isAnimating = true;
          window.animCards = cards.map((c) => ({ ...c }));
          window.animIsUser = isUser;
          const arr = isUser ? userCards : opponentCards;
          const spacing = CARD_W * 0.55;
          const totalW = (arr.length - 1) * spacing + CARD_W;
          const startX = (canvas.width - totalW) / 2;
          let firstIdx = 0;
          if (isUser) {
            firstIdx = arr.findIndex(
              (c) => c.suit === cards[0].suit && c.num === cards[0].num
            );
          }
          window.animFromX = startX + firstIdx * spacing;
          window.animFromY = isUser ? USER_Y : OPP_Y;
          window.animToX = TOPCARD_X;
          window.animToY = TOPCARD_Y;
          window.animStep = 0;
          playSound("throw");
          window.showMessage(
            isUser ? "Poa sana!" : "Mpinzani ametupa!",
            "#0f0"
          );

          setTimeout(() => {
            if (topCard) recentPlayedCards.push(topCard);
            cards.forEach((c) => recentPlayedCards.push(c));
            recentPlayedCards = recentPlayedCards.slice(-5);
            topCard = cards[cards.length - 1];

            if (isUser) {
              userCards = userCards.filter(
                (c) =>
                  !cards.some((dc) => dc.suit === c.suit && dc.num === c.num)
              );
              userCards.forEach((c) => {
                c.ready = false;
                c.float = false;
              });
            } else {
              opponentCards.splice(0, cards.length);
            }

            const feeder = [1, 2].includes(topCard.num);
            if (isQuestion(topCard)) {
              window.showMessage("FUNIKA HII KADI!", "#ff0");
            } else if (feeder) {
              window.showMessage(
                topCard.num === 1 ? "KULA 2!" : "KULA 3!",
                "#f00"
              );
              shouldEat = true;
              myTurn = !isUser;
            } else {
              shouldEat = false;
              myTurn = !isUser;
              window.showMessage(
                myTurn ? "Zamuu yako!" : "Mpinzani anacheza...",
                myTurn ? "#0f0" : "#ff0",
                2000
              );
            }
            checkGameOver();
            isAnimating = false;
          }, 900);
        };

        window.pickCardsLocal = function (cards, isUser) {
          if (isAnimating || gameState !== "ready") return;
          if (!cards || cards.length === 0) {
            console.error("No cards to pick!");
            return;
          }

          isAnimating = true;
          window.animCards = cards.map((c) => ({ ...c }));
          window.animIsUser = isUser;

          const spacing = CARD_W * 0.55;
          const totalW =
            ((isUser ? userCards.length : opponentCards.length) +
              cards.length -
              1) *
              spacing +
            CARD_W;
          const startX = (canvas.width - totalW) / 2;
          const base = isUser ? userCards.length : opponentCards.length;
          window.animFromX = DECK_X;
          window.animFromY = DECK_Y;
          window.animToX = startX + base * spacing;
          window.animToY = isUser ? USER_Y : OPP_Y;
          window.animStep = 0;
          playSound("pick");
          window.showMessage(
            isUser ? "Umechukua!" : "Mpinzani anachukua",
            "#fff"
          );

          setTimeout(() => {
            if (isUser) {
              userCards.push(
                ...window.animCards.map((c) => ({
                  ...c,
                  float: false,
                  ready: false,
                }))
              );
            } else {
              for (let i = 0; i < cards.length; i++) {
                opponentCards.push({ suit: null, num: null });
              }
            }
            isAnimating = false;
            shouldEat = false;
            messageEl.textContent = "";

            if (isUser) {
              myTurn = false;
              window.showMessage("Subiri kidogo...", "#ff0", 2000);
            } else {
              myTurn = true;
              window.showMessage("Zamuu yako!", "#0f0", 2000);
            }

            checkGameOver();
          }, 900);
        };

        function isQuestion(card) {
          return card && [7, 10, 11, 12].includes(card.num);
        }
        function canFinish(card) {
          return card && ![0, 1, 2, 7, 10, 11, 12].includes(card.num);
        }
        function isValid(top, cards, eat) {
          if (!cards.length || !top) return false;
          let prev = top;
          for (let i = 0; i < cards.length; i++) {
            const c = cards[i],
              first = i === 0;
            if (eat) {
              if (first) {
                if (c.num !== prev.num && c.num !== 0) return false;
              } else if (c.num !== prev.num) return false;
            } else if (!first) {
              if (isQuestion(prev)) {
                if (
                  !(c.suit === prev.suit || c.num === prev.num || c.num === 0)
                )
                  return false;
              } else if (c.num !== prev.num) return false;
            } else if (
              !(c.suit === prev.suit || c.num === prev.num || c.num === 0)
            )
              return false;
            prev = c;
          }
          return true;
        }

        function checkGameOver() {
          if (
            userCards.length === 0 &&
            topCard &&
            canFinish(topCard) &&
            opponentCards.length > 0
          ) {
            playerScore++;
            winText.textContent = "UMESHINDA!!!";
            winText.style.color = "#0f0";
            winScreen.classList.add("show");
            confetti({ particleCount: 600, spread: 140, origin: { y: 0.55 } });
            playSound("win");
            gameDone = true;
            updateScore();
          }
          if (
            opponentCards.length === 0 &&
            topCard &&
            canFinish(topCard) &&
            userCards.length > 0
          ) {
            computerScore++;
            winText.textContent = "MPINZANI AMESHINDA!";
            winText.style.color = "#f00";
            winScreen.classList.add("show");
            gameDone = true;
            updateScore();
          }
        }

        function getHit(x, y) {
          const spacing = CARD_W * 0.7;
          const totalW = (userCards.length - 1) * spacing + CARD_W;
          const startX = (canvas.width - totalW) / 2;
          for (let i = userCards.length - 1; i >= 0; i--) {
            const card = userCards[i];
            const cx = startX + i * spacing;
            const dy = (card.float ? -35 : 0) + (card.ready ? -50 : 0);
            const left = cx + CARD_W * 0.05,
              right = cx + CARD_W * 0.95;
            const top = USER_Y + dy,
              bottom = USER_Y + dy + CARD_H;
            if (x >= left && x <= right && y >= top && y <= bottom)
              return { type: "user", idx: i };
          }
          if (
            allCards.length > 0 &&
            x > DECK_X - 30 &&
            x < DECK_X + CARD_W + 30 &&
            y > DECK_Y - 30 &&
            y < DECK_Y + CARD_H + 30
          )
            return { type: "deck" };
          if (
            x > canvas.width * 0.3 &&
            x < canvas.width * 0.7 &&
            y > canvas.height * 0.3 &&
            y < canvas.height * 0.7
          )
            return { type: "top" };
          if (
            x > BUTTON_X &&
            x < BUTTON_X + BUTTON_W &&
            y > BUTTON_Y &&
            y < BUTTON_Y + BUTTON_H
          )
            return { type: "restart" };
          return null;
        }

        function getInputXY(e) {
          const rect = canvas.getBoundingClientRect();
          const ev = e.touches ? e.touches[0] : e;
          if (!ev) return { x: 0, y: 0 };
          return {
            x: (ev.clientX - rect.left) * (canvas.width / rect.width),
            y: (ev.clientY - rect.top) * (canvas.height / rect.height),
          };
        }

        function handleStart(x, y) {
          if (!myTurn || isAnimating || gameDone || gameState !== "ready")
            return;
          const hit = getHit(x, y);
          if (hit?.type === "user") {
            dragCard = {
              card: userCards[hit.idx],
              idx: hit.idx,
              x: x - CARD_W / 2,
              y: y - CARD_H / 2,
            };
            userCards[hit.idx].float = true;
          }
        }

        function handleMove(x, y) {
          if (!dragCard) return;
          dragCard.x = x - CARD_W / 2;
          dragCard.y = y - CARD_H / 2;
        }

        function handleEnd(x, y) {
          const hit = getHit(x, y);
          if (hit?.type === "restart") {
            socket.emit("rematch", { roomId });
            return;
          }
          if (!myTurn || isAnimating || gameDone || gameState !== "ready")
            return;
          if (hit?.type === "deck") {
            const num = shouldEat ? (topCard.num === 1 ? 2 : 3) : 1;
            pickCards(num, true);
            userCards.forEach((c) => (c.float = false));
            dragCard = null;
            return;
          }
          if (hit?.type === "top") {
            const ready = userCards.filter((c) => c.ready);
            if (ready.length > 0)
              dropCards(
                ready.map((c) => ({ suit: c.suit, num: c.num })),
                true
              );
            else window.showMessage("Chagua kadi ya kutupa!", "#ff0");
            userCards.forEach((c) => (c.float = false));
            dragCard = null;
            return;
          }
          if (dragCard) {
            const dx = x - (dragCard.x + CARD_W / 2);
            if (Math.abs(dx) > 70) {
              const dir = dx > 0 ? 1 : -1;
              const newIdx = dragCard.idx + dir;
              if (newIdx >= 0 && newIdx < userCards.length)
                [userCards[dragCard.idx], userCards[newIdx]] = [
                  userCards[newIdx],
                  userCards[dragCard.idx],
                ];
            } else
              userCards[dragCard.idx].ready = !userCards[dragCard.idx].ready;
          }
          userCards.forEach((c) => (c.float = false));
          dragCard = null;
        }

        canvas.addEventListener(
          "touchstart",
          (e) => {
            e.preventDefault();
            const p = getInputXY(e);
            handleStart(p.x, p.y);
          },
          { passive: false }
        );
        canvas.addEventListener(
          "touchmove",
          (e) => {
            e.preventDefault();
            const p = getInputXY(e);
            handleMove(p.x, p.y);
          },
          { passive: false }
        );
        canvas.addEventListener(
          "touchend",
          (e) => {
            e.preventDefault();
            const p = getInputXY(e);
            handleEnd(p.x, p.y);
          },
          { passive: false }
        );
        canvas.addEventListener("mousedown", (e) => {
          const p = getInputXY(e);
          handleStart(p.x, p.y);
        });
        canvas.addEventListener("mousemove", (e) => {
          const p = getInputXY(e);
          handleMove(p.x, p.y);
        });
        canvas.addEventListener("mouseup", (e) => {
          const p = getInputXY(e);
          handleEnd(p.x, p.y);
        });

        function dropCards(cards, isUser) {
          if (isUser && roomId) {
            sendMove({
              type: "drop",
              cards: cards.map((c) => ({ suit: c.suit, num: c.num })),
            });
          }
          window.dropCardsLocal(cards, isUser);
        }

        function pickCards(num, isUser) {
          if (!isUser) return;
          if (isUser && roomId) {
            sendMove({ type: "pick", num });
          }
        }

        let loaded = 0;
        const expected = Object.keys(cardImages).length + 2;
        function imgLoaded() {
          loaded++;
          if (loaded >= expected) {
            resize();
            requestAnimationFrame(draw);
          }
        }
        deckBack.onload = imgLoaded;
        oppBack.onload = imgLoaded;
        Object.values(cardImages).forEach((img) => (img.onload = imgLoaded));
        setTimeout(() => {
          if (gameState === "loading") {
            resize();
            requestAnimationFrame(draw);
          }
        }, 1500);
      })();

      function goHome() {
        window.location.href = "welcome.html";
      }
      document.getElementById("playAgainBtn").addEventListener("click", () => {
        socket.emit("rematch", { roomId });
      });
    </script>
  </body>
</html>
